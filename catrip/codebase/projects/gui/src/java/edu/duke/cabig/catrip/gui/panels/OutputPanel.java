
package edu.duke.cabig.catrip.gui.panels;

import edu.duke.cabig.catrip.gui.common.AttributeBean;
import edu.duke.cabig.catrip.gui.common.ClassBean;
import edu.duke.cabig.catrip.gui.components.CPanel;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Vector;
import javax.swing.table.DefaultTableModel;

/**
 * Out Panel to show the results from the DCQL Query execution.
 * It has a dynamic Table Model, where the Table columns are shown based on the Target object selected on the Graph.
 *
 * @author  Sanjeev Agarwal
 */
public class OutputPanel extends CPanel {
    
    
    /** Creates new form OutputPanel */
    public OutputPanel() {
        initComponents();
    }
    
    public javax.swing.JTable getOutputTable() {
        return outputTable;
    }
    
    public void setResults(ArrayList resultArray){
        getOutputTable().setModel(getTableModel(resultArray));
    }

    public void setMapResults(List resultArray, HashMap colNamesMap, String[] keys){
        getOutputTable().setModel(getMapTableModel(resultArray, colNamesMap, keys));
    }
    
    public void cleanResults(){
        getOutputTable().setModel(getTableModel());
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Netbeans Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        jScrollPane1 = new javax.swing.JScrollPane();
        outputTable = new javax.swing.JTable();

        setLayout(new java.awt.GridLayout(1, 0));

        outputTable.setModel(getTableModel());
        jScrollPane1.setViewportView(outputTable);

        add(jScrollPane1);

    }// </editor-fold>//GEN-END:initComponents
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable outputTable;
    // End of variables declaration//GEN-END:variables
    
    private DefaultTableModel getTableModel(){
        return new javax.swing.table.DefaultTableModel();
    }
    
    /** This method assumes that the Target object and the results are an instance of type ClassBean. */
    private DefaultTableModel getTableModel(ArrayList array){
        Vector rowV = new Vector();
        Vector colNames = null;
        
        for (int i = 0; i < array.size(); i++){  // TODO - restrict it to only 100 rows or so.
            
            ClassBean b = (ClassBean) array.get(i);
            ArrayList at = b.getAttributes();
            Vector colV = new Vector();
            colNames = new Vector();
            for (int j = 0; j< at.size();j++){
                AttributeBean att = (AttributeBean)at.get(j);
                colV.add(att.getAttributeValue());
                colNames.add(att.getCDEName()); // don't do it everytime...
            }
            rowV.add(colV);
            
        }
        
        DefaultTableModel tb = new javax.swing.table.DefaultTableModel(rowV, colNames){
            public boolean isCellEditable(int row, int col) {
                return false;
            }
        };
        
        return tb;
    }
    
    
    
    /** This method assumes that the Target object and the results are an instance of type ClassBean. */
    private DefaultTableModel getMapTableModel(List array, HashMap colNamesMap, String[] keys){ 
        Vector rowV = new Vector();
        Vector colNames = new Vector();
        
        for (int i = 0; i < keys.length; i++) { 
            colNames.add(colNamesMap.get(keys[i]));
        }
        
        for (int i = 0; i < array.size(); i++){  
            Object obj = array.get(i);
            
            HashMap map = (HashMap)obj;
            Vector colV = new Vector();
            for (int j = 0; j< keys.length;j++){
                colV.add(map.get(keys[j]));
            }
            rowV.add(colV);
        }
        
        DefaultTableModel tb = new javax.swing.table.DefaultTableModel(rowV, colNames){
            public boolean isCellEditable(int row, int col) {
                return false;
            }
        };
        
        return tb;
    }
    
}
