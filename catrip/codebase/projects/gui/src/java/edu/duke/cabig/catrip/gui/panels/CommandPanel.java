
package edu.duke.cabig.catrip.gui.panels;


import edu.duke.cabig.catrip.gui.common.AttributeBean;
import edu.duke.cabig.catrip.gui.common.ClassBean;
import edu.duke.cabig.catrip.gui.components.CJDialog;
import edu.duke.cabig.catrip.gui.components.CPanel;
import edu.duke.cabig.catrip.gui.discovery.DomainModelMetaDataRegistry;
import edu.duke.cabig.catrip.gui.query.DCQLGenerator;
import edu.duke.cabig.catrip.gui.query.DCQLRegistry;
import edu.duke.cabig.catrip.gui.query.GroupDCQLGenerator;
import edu.duke.cabig.catrip.gui.simplegui.SimpleGuiRegistry;
import edu.duke.cabig.catrip.gui.util.DisplayExceptions;
import edu.duke.cabig.catrip.gui.util.GUIConstants;
import edu.duke.cabig.catrip.gui.util.Logger;
import gov.nih.nci.cagrid.cqlresultset.CQLObjectResult;
import gov.nih.nci.cagrid.cqlresultset.CQLQueryResults;
import gov.nih.nci.cagrid.dcql.DCQLQuery;
import gov.nih.nci.cagrid.fqp.processor.FederatedQueryEngine;
import gov.nih.nci.cagrid.fqp.tools.DataGroup;
import gov.nih.nci.cagrid.fqp.tools.ResultsParser;
import java.awt.Cursor;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;
import javax.swing.JOptionPane;
import javax.swing.JProgressBar;
import org.apache.axis.message.MessageElement;
import org.apache.axis.message.PrefixedQName;
import org.apache.commons.logging.Log;

/**
 * Panel which contains the Execute button. More commands can be added here.
 *
 * @author  Sanjeev Agarwal
 */
public class CommandPanel extends CPanel {
    // TODO - set the variable somewhere else...
    
    boolean processingDone = false;
    JProgressBar progressBar ;
    CJDialog progressBarWindow ;
    
    Log log = Logger.getDefaultLogger(); 
    
    /** Creates new form CommandPanel */
    public CommandPanel() {
        initComponents();
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Netbeans Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        pnlOne = new javax.swing.JPanel();
        resultCountLbl = new javax.swing.JLabel();
        pnlTwo = new javax.swing.JPanel();
        ExecuteCommand = new javax.swing.JButton();

        setLayout(new java.awt.GridLayout(1, 0));

        pnlOne.setLayout(new java.awt.GridLayout(1, 0));

        resultCountLbl.setFont(new java.awt.Font("Arial", 1, 14));
        pnlOne.add(resultCountLbl);

        add(pnlOne);

        ExecuteCommand.setIcon(new javax.swing.ImageIcon(getClass().getResource("/edu/duke/cabig/catrip/gui/resources/btn_icons/execute.gif")));
        ExecuteCommand.setText("Execute Query");
        ExecuteCommand.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ExecuteCommandActionPerformed(evt);
            }
        });

        pnlTwo.add(ExecuteCommand);

        add(pnlTwo);

    }// </editor-fold>//GEN-END:initComponents
    
    private void showProgressBar(){
        progressBar = new JProgressBar();
        progressBar.setIndeterminate(true);
        progressBarWindow = new CJDialog(getMainFrame(), "Executing the query.");
        progressBarWindow.add(progressBar);
        progressBarWindow.setBounds(10,10,570, 50);
        progressBarWindow.center();progressBarWindow.setModal(true);
//        progressBarWindow.setDefaultCloseOperation(CJDialog.DO_NOTHING_ON_CLOSE);
        progressBarWindow.setVisible(true);
    }
    
    private void hideProgressBar(){
        progressBar.setIndeterminate(false);
        progressBarWindow.setVisible(false);
        progressBarWindow.dispose();
    }
    
    private void beforeExecution(){
        getMainFrame().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
        ExecuteCommand.setEnabled(false);
        
        new Thread() {
            public void run() {
                showProgressBar();
            }
        }.start();
        
    }
    
    private void afterExecution(){
        getMainFrame().setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
        ExecuteCommand.setEnabled(true);
        hideProgressBar();
        
    }
    
    private void ExecuteCommandActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ExecuteCommandActionPerformed
        
        beforeExecution();
        
        
        new Thread() {
            public void run() {
                
                if (GUIConstants.simpleGui){
                    if (SimpleGuiRegistry.isSimpleGuiChanged()){
                        SimpleGuiRegistry.prepareForDcql();
                    }
                    executeReturnAttributeQuery(); // it always has returned attribute now..
                }else {
                    executeVisualGuiQuery();
                }
                
            }
        }.start();
        
    }//GEN-LAST:event_ExecuteCommandActionPerformed
    public void runExternalDcql(final DCQLQuery dcql){
        beforeExecution();
        
        new Thread() {
            public void run() {
                runOnlyDcql(dcql);
            }
        }.start();
    }
    
    
    public void runOnlyDcql(DCQLQuery dcql){
        ExecuteCommand.setEnabled(false);
        // assume that the parser can parse the results and use the same mechanism to show the results..
        
        try {
            resultCountLbl.setText("   ");
            FederatedQueryEngine fqe = new FederatedQueryEngine();
            getMainFrame().getOutputPanel().cleanResults();
            CQLQueryResults results = fqe.executeAndAggregateResults(dcql);
            
            ResultsParser parser = new ResultsParser(dcql);//,dcql.getTargetObject().getName());
            List dataGroupList = parser.getResultList(results);
            List resultList = new ArrayList();
            ArrayList rColorsFlags = new ArrayList(); boolean change=false;
            
            for (int i = 0; i < dataGroupList.size(); i++) {
                DataGroup dg = (DataGroup)dataGroupList.get(i);
                List list = dg.getDataRows(); // list of maps..
                for (int j = 0; j < list.size(); j++) {
                    resultList.add(list.get(j));
                    rColorsFlags.add(new Boolean(change));
                }
                change=change?false:true;
            }
            // TODO - do it decently.. or pass the List instead of Array.
            boolean[] atlertaneCols = new boolean[rColorsFlags.size()];
            for (int i = 0; i < atlertaneCols.length; i++) {
                atlertaneCols[i] = ((Boolean)rColorsFlags.get(i)).booleanValue();
            }
            
            
            // instead of getting the composite keys a nd CDE names.. from registry.. calculate it..
            String[] compositMapKeys; // = new String[SimpleGuiRegistry.getNumReturnedAttribute()];
            HashMap colNamesMap = new HashMap();
            
            int k = 0;
            if (resultList.size() > 0){
                Map resultMap = (Map)resultList.get(0);
                compositMapKeys = new String[resultMap.size()];
                
//                System.out.println("XXXX query sharing result column Map size :"+resultMap.size());
                
                Iterator keys = resultMap.keySet().iterator();
                while (keys.hasNext()) {
                    String key = keys.next().toString();
                    String className = key.substring(0,key.indexOf("-"));
                    String attributeName = key.substring(key.indexOf("-")+1, key.length());
                    ClassBean cBean = DomainModelMetaDataRegistry.lookupClassByFullyQualifiedName(className).clone();
                    cBean.filterAttributes(new String[]{attributeName});
                    String attCdeName = cBean.getAttributes().get(0).getCDEName();
                    
                    compositMapKeys[k] = key;
                    colNamesMap.put(key, attCdeName);
                    k++;
                }
                
//                getMainFrame().getOutputPanel().setMapResults(resultList,colNamesMap, compositMapKeys, atlertaneCols);
//                GUIConstants.resultAvailable = true;
//                resultCountLbl.setText("   Total Row Count : "+resultList.size());
                
                
                // final variables just for the inner class.
                final List _resultList = resultList;
                final HashMap _colNamesMap = colNamesMap;
                final String[] _compositMapKeys = compositMapKeys;
                final boolean[] _atlertaneCols = atlertaneCols;
                final String txt = "   Total Row Count : "+resultList.size();
                
                java.awt.EventQueue.invokeLater(new Runnable() {
                    public void run() {
                        getMainFrame().getOutputPanel().setMapResults(_resultList, _colNamesMap, _compositMapKeys, _atlertaneCols);
                        resultCountLbl.setText(txt);
                        GUIConstants.resultAvailable = true;
                        afterExecution();
                    }
                });
                
            }
            
            
        } catch (final Exception ex) {
//            ex.printStackTrace();
            
            java.awt.EventQueue.invokeLater(new Runnable() {
                public void run() {
                    resultCountLbl.setText(" ");
                    afterExecution();
                    DisplayExceptions.display("Error.", "Error executing the Query.", ex);
                }
            });
            
        }
        
        
        
        ExecuteCommand.setEnabled(true);
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton ExecuteCommand;
    private javax.swing.JPanel pnlOne;
    private javax.swing.JPanel pnlTwo;
    private javax.swing.JLabel resultCountLbl;
    // End of variables declaration//GEN-END:variables
    
    
    public void disableBtn(){
        ExecuteCommand.setEnabled(false);
    }
    public void enableBtn(){ 
        ExecuteCommand.setEnabled(true);
    }
    
    
    private void executeSimpleGuiQuery(){
        
        if (SimpleGuiRegistry.isSimpleGuiChanged()){
            SimpleGuiRegistry.prepareForDcql();
        }
        executeVisualGuiQuery();
        
    }
    
    private void executeReturnAttributeQuery(){
        try {
            resultCountLbl.setText("   ");
            FederatedQueryEngine fqe = new FederatedQueryEngine();
            DCQLQuery dcql = GroupDCQLGenerator.getDCQLDocument();
            
            // log the DCQL.
            log.info("---- DCQL Text Start ---- \n"+GroupDCQLGenerator.getDCQLText() + "\n---- DCQL Text End ----\n\n");

//            System.out.println(GroupDCQLGenerator.getDCQLText());
            
            getMainFrame().getOutputPanel().cleanResults();
            
            
            CQLQueryResults results = fqe.executeAndAggregateResults(dcql);
            
            
            ResultsParser parser = new ResultsParser(dcql);//,dcql.getTargetObject().getName());
            List dataGroupList = parser.getResultList(results);
            List resultList = new ArrayList();
            ArrayList rColorsFlags = new ArrayList(); boolean change=false;
            
            for (int i = 0; i < dataGroupList.size(); i++) {
                DataGroup dg = (DataGroup)dataGroupList.get(i);
                List list = dg.getDataRows(); // list of maps..
                for (int j = 0; j < list.size(); j++) {
                    resultList.add(list.get(j));
                    rColorsFlags.add(new Boolean(change));
                }
                change=change?false:true;
            }
            // TODO - do it decently.. or pass the List instead of Array.
            boolean[] atlertaneCols = new boolean[rColorsFlags.size()];
            for (int i = 0; i < atlertaneCols.length; i++) {
                atlertaneCols[i] = ((Boolean)rColorsFlags.get(i)).booleanValue();
            }
            
            
            // TODO - testing..
            
//            System.out.println("XXXX Return Attribute Query result column Map size :"+((Map)((DataGroup)dataGroupList.get(0)).getDataRows().get(0)).size());
            
            
            
            HashMap cMap = SimpleGuiRegistry.getClassNameReturnedAttributeMap();
            String[] compositMapKeys = new String[SimpleGuiRegistry.getNumReturnedAttribute()];
            HashMap colNamesMap = new HashMap();
            
            int k = 0;
            Iterator keys = cMap.keySet().iterator();
            while (keys.hasNext()) {
                String className = keys.next().toString();
                List atts = (List)cMap.get(className);
                String[] attArray = (String[])atts.toArray(new String[atts.size()]); // un necessary.. conversion
                
                ClassBean cBean = DomainModelMetaDataRegistry.lookupClassByFullyQualifiedName(className).clone();
                cBean.filterAttributes(attArray);
                // now this classBean is a returned only attribute bean..
//                ArrayList attributes = cBean.getAttributes();
                for (int i = 0; i < attArray.length; i++) {
                    AttributeBean aBean = (AttributeBean)cBean.getAttributes().get(i) ;
                    compositMapKeys[k] = cBean.getFullyQualifiedName()+"-"+ attArray[i];
                    colNamesMap.put(compositMapKeys[k], aBean.getCDEName());//cBean.getCDEName()+" "+aBean.getCDEName());  // TODO - show the class CDE name also..
                    k++;
                }
            }
            
//            getMainFrame().getOutputPanel().setMapResults(resultList,colNamesMap, compositMapKeys, atlertaneCols);
//            resultCountLbl.setText("   Total Row Count : "+resultList.size());
//            GUIConstants.resultAvailable = true;
            
            // final variables just for the inner class.
            final List _resultList = resultList;
            final HashMap _colNamesMap = colNamesMap;
            final String[] _compositMapKeys = compositMapKeys;
            final boolean[] _atlertaneCols = atlertaneCols;
            final String txt = "   Total Row Count : "+resultList.size();
            
            java.awt.EventQueue.invokeLater(new Runnable() {
                public void run() {
                    getMainFrame().getOutputPanel().setMapResults(_resultList, _colNamesMap, _compositMapKeys, _atlertaneCols);
                    resultCountLbl.setText(txt);
                    GUIConstants.resultAvailable = true;
                    
                    afterExecution();
                }
            });
            
            
        } catch (final Exception ex) {
//            ex.printStackTrace();
            
            java.awt.EventQueue.invokeLater(new Runnable() {
                public void run() {
                    resultCountLbl.setText(" ");
                    afterExecution();
                    DisplayExceptions.display("Error.", "Error executing the Query.", ex);
                }
            });
            
            
        }
    }
    
    
    private void executeVisualGuiQuery(){
        try {

            long startTime = System.currentTimeMillis();
            
            FederatedQueryEngine fqe = new FederatedQueryEngine();
            DCQLQuery dcqlQueryDocument = DCQLGenerator.getDCQLDocument();
            // sanjeev: if the dcqlQueryDocument is null throw the error Dialog.

            
            long dcqlGenerationTime = System.currentTimeMillis();
            
            System.out.println("Total time taken in Generating the DCQL: "+  (dcqlGenerationTime-startTime) +" Milli Seconds" );
            
            
            // sanjeev: clean the result table before you even try the new query...
            getMainFrame().getOutputPanel().cleanResults();
            
            CQLQueryResults results = fqe.executeAndAggregateResults(dcqlQueryDocument);
            
            
            
            /*
            CQLObjectResult[] objectResult = results.getObjectResult();
            System.out.println(objectResult.length);
            for (int i = 0; i < objectResult.length; i++) {
                CQLObjectResult objResult = objectResult[i];
                MessageElement msgsElement = (MessageElement)objResult.get_any()[0];
                Iterator itt = msgsElement.getAllAttributes();
                while (itt.hasNext()){
//                        System.out.println(itt.next().getClass().getName());
                    PrefixedQName key = (PrefixedQName)itt.next();
                    String value = msgsElement.getAttributeValue(key);
//                        System.out.println("Key = "+key.getLocalName()+" Value = "+value);
                }
             
//                    System.out.println(objResult.get_any()[0]);
             
            }
             */
            
            
            
            long queryExecutionTime = System.currentTimeMillis();
            System.out.println("Total time taken in Query Execution: "+  (queryExecutionTime-dcqlGenerationTime) +" Milli Seconds" );
            
            if ( (results == null) || (results.getObjectResult() == null) || (results.getObjectResult().length == 0) ){
                JOptionPane.showMessageDialog(getMainFrame(), "No results found. Please check your query.");
                resultCountLbl.setText("   ");
            } else {
                
                // TODO - put the client config files of the individual service also in the caTRIP-config.xml or the services-mapping file some how.
//                CQLQueryResultsIterator iterator = new CQLQueryResultsIterator(results, new FileInputStream(new File(GUIConfigurationLoader.getGUIConfiguration().getConfigRootLocation() + File.separator +"client-config.wsdd")));
                
                
                
                long resultIteratorTime = System.currentTimeMillis();
//                System.out.println("Total time taken in getting the Result Iterator: "+  (resultIteratorTime-queryExecutionTime) +" Milli Seconds" );
                
                CQLObjectResult[] objectResult = results.getObjectResult();
                
                ArrayList classBeanList = new ArrayList();
                
                ClassBean tmpObject = DCQLRegistry.getTargetNode().getAssociatedClassObject();
                
//                while (iterator.hasNext()) {
//                    Object obj = iterator.next();
                
                for (int ii = 0; ii < objectResult.length ; ii++) {
                    
                    HashMap tmpKeyValueMap = new HashMap();
                    
                    CQLObjectResult objResult = objectResult[ii];
                    MessageElement msgsElement = (MessageElement)objResult.get_any()[0];
                    Iterator itt = msgsElement.getAllAttributes();
                    while (itt.hasNext()){
//                        System.out.println(itt.next().getClass().getName());
                        PrefixedQName key = (PrefixedQName)itt.next();
                        String value = msgsElement.getAttributeValue(key).trim();
                        String stringKey = key.getLocalName().toString().trim();
                        // sample date string : "1947-01-01T00:00:00.000-05:00";
                        String dateFormatExp = "\\d\\d\\d\\d[-]\\d\\d[-]\\d\\d[T]\\d\\d[:]\\d\\d[:]\\d\\d[.]\\d\\d\\d[-]\\d\\d[:]\\d\\d";
                        boolean b = Pattern.matches(dateFormatExp, value);
                        if (b){
                            Date javaDate = (new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS")).parse(value);
                            value = javaDate.toString();
                        }
                        
                        
                        tmpKeyValueMap.put(stringKey, value.trim() );
//                        System.out.println("Key = "+key.getLocalName()+" Value = "+value);
                    }
                    
                    
                    ClassBean classBeanTmp = tmpObject.clone();
                    
                    ArrayList attributeList = classBeanTmp.getAttributes();
                    
                    for (int i = 0; i < attributeList.size(); i++) {
                        AttributeBean aBean = (AttributeBean) attributeList.get(i);
//                        String attributeName = aBean.getAttributeName();
//                        String methodName ="get"+attributeName.substring(0,1).toUpperCase() + attributeName.substring(1);
                        String value = " ";
                        try{
//                            Object attributeValue = ((Method)obj.getClass().getMethod(methodName)).invoke(obj);
                            value = tmpKeyValueMap.get(aBean.getAttributeName().trim()).toString();
//                            if (attributeValue != null){
//                                value = attributeValue.toString();
//                            }
                        } catch (Exception eex) {
//                            System.out.println("No/Null value of attribute : "+aBean.getAttributeName().trim());
//                            eex.printStackTrace();
                        }
                        aBean.setAttributeValue(value);
                    }
                    
                    
                    classBeanList.add(classBeanTmp);
                    
                }
                
                long serializationTime = System.currentTimeMillis();
//                System.out.println("Total time taken in Serialization and Reflection: "+  (serializationTime-resultIteratorTime) +" Milli Seconds" );
                System.out.println("Total time taken in xml parsing : "+  (serializationTime-resultIteratorTime) +" Milli Seconds" );
                
                 // TODO -SB- add this to SwingUtilities.invokeLater method..
                resultCountLbl.setText("   Total Row Count : "+classBeanList.size());
                getMainFrame().getOutputPanel().setResults(classBeanList);  // TODO -SB- use the same mechanisl to load the display both in simple and advance gui..
                
                long resultDisplayTime = System.currentTimeMillis();
                System.out.println("Total time taken in Result Display: "+  (resultDisplayTime-serializationTime) +" Milli Seconds" );
                
                // sanjeev: set that results are available for export..
                GUIConstants.resultAvailable = true;
//                HTMLResultExporter.exportToHtml( getMainFrame().getOutputPanel().getOutputTable());
                
                
                afterExecution();
            }
            
        } catch (Exception ex) {
            afterExecution();
            
            resultCountLbl.setText(" ");
            DisplayExceptions.display("Error.", "Error executing the Query.", ex);
//            ex.printStackTrace();
        }
    }
    
    
}
